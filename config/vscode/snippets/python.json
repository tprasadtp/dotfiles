{
  "Copyright-PythonScript": {
      "prefix": [
          "pyscript"
      ],
      "body": [
          "#!/usr/bin/env python",
          "# -*- coding: utf-8 -*-",
          "#  Copyright (c) 2019-$CURRENT_YEAR Prasad Tengse",
          "#",
          ""
      ],
      "description": "Adds the copyright to python scripts...",
      "scope": "python"
  },
  "Copyright-Python": {
    "prefix": [
        "pyheader",
        "pycopyrights"
    ],
    "body": [
        "# -*- coding: utf-8 -*-",
        "#  Copyright (c) 2019-$CURRENT_YEAR Prasad Tengse",
        "#",
        ""
    ],
    "description": "Adds the copyright to python files...",
    "scope": "python"
},
"Redacting-Filter": {
  "prefix": "redactfilter",
  "body": [
    "# Standard Library Imports",
    "import logging",
    "import re",
    "",
    "SENSITIVE_REGEX = [",
    "    re.compile(r\"[0-9a-zA-Z+\\\\]{40}\"),",
    "    re.compile(",
    "        r\"(A3T[A-Z0-9]|AKIA|AGPA|AIDA|AROA|\" r\"AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16}\"",
    "    ),",
    "]",
    "",
    "",
    "class RedactingFilter(logging.Filter):",
    "    # Do not try and redact the built in values.",
    "    ignore_keys = [",
    "        \"name\",",
    "        \"levelname\",",
    "        \"levelno\",",
    "        \"pathname\",",
    "        \"filename\",",
    "        \"module\",",
    "        \"exc_info\",",
    "        \"exc_text\",",
    "        \"stack_info\",",
    "        \"lineno\",",
    "        \"funcName\",",
    "        \"created\",",
    "        \"msecs\",",
    "        \"relativeCreated\",",
    "        \"thread\",",
    "        \"threadName\",",
    "        \"process\",",
    "        \"processName\",",
    "        \"args\",",
    "    ]",
    "",
    "    def __init__(self, patterns, default_mask=\"*******\", num_mask=00000):",
    "        super(RedactingFilter, self).__init__()",
    "        self._patterns = patterns",
    "        self._default_mask = str(default_mask)",
    "        self._num_mask = str(num_mask)",
    "",
    "    def filter(self, record):",
    "        d = vars(record)",
    "        for k, content in d.items():",
    "            if k not in self.ignore_keys:",
    "                d[k] = self.redact(content)",
    "",
    "        # Also clean any contents in args",
    "        if isinstance(record.args, dict):",
    "            for k in record.args.keys():",
    "                record.args[k] = self.redact(record.args[k])",
    "        else:",
    "            record.args = tuple(self.redact(arg) for arg in record.args)",
    "",
    "        return True",
    "",
    "    def redact(self, content):",
    "        if content:",
    "            if isinstance(content, dict):",
    "                for k, v in content.items():",
    "                    content[k] = self.redact(v)",
    "",
    "            elif isinstance(content, (list, tuple)):",
    "                for i, v in enumerate(content):",
    "                    content[i] = self.redact(v)",
    "",
    "            elif isinstance(content, str):",
    "                for pattern in self._patterns:",
    "                    content = re.sub(pattern, self._default_mask, content)",
    "",
    "            elif isinstance(content, int):",
    "                for pattern in self._patterns:",
    "                    content = re.sub(pattern, self._num_mask, str(content))",
    "                    return int(content)",
    "",
    "            elif isinstance(content, float):",
    "                for pattern in self._patterns:",
    "                    content = re.sub(pattern, self._num_mask, str(content))",
    "                    return float(content)",
    "",
    "        return content",
    ""
  ],
  "description": "Redact Logs in Python"
},
"python-loglevel": {
  "prefix": "loglevel-snip",
  "body": [
    "import logging",
    "from pathlib import Path",
    "import sys",
    "from typing import List, Optional",
    "",
    "",
    "def get_log_level(",
    "    q_count: int = 0, v_count: int = 0, debug_modules: Optional[List(str)] = None",
    ") -> int:",
    "    \"\"\"",
    "    sets log level",
    "    :param q_count: Number of times flag -q is passed",
    "    :type q_count: int",
    "    :param v_count: Number of times flag -v is passed",
    "    :type: v_count: int",
    "    \"\"\"",
    "",
    "    if q_count is None:",
    "        q_count = 0",
    "",
    "    if v_count is None:",
    "        v_count = 0",
    "",
    "    log_lvl = int(1) + int(q_count) - int(v_count)",
    "",
    "    if log_lvl <= 0:",
    "        rv = logging.DEBUG",
    "        # check if additional modules need to be debugged",
    "        if debug_modules is not None:",
    "            for _module in debug_modules:",
    "                # check if module is loaded, and enable debug logs on it",
    "                if _module in sys.modules:",
    "                    logging.getLogger(_module).setLevel(logging.DEBUG)",
    "",
    "    elif log_lvl == 1:",
    "        rv = logging.INFO",
    "    elif log_lvl == 2:",
    "        rv = logging.WARNING",
    "    elif log_lvl == 3:",
    "        rv = logging.ERROR",
    "    elif log_lvl > 3:",
    "        rv = logging.CRITICAL",
    "    return rv",
    ""
  ],
  "description": "python-loglevel"
}
}
