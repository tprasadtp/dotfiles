#!/usr/bin/env bash
# Copyright (c) 2021. Prasad Tengse
#
# shellcheck disable=SC2155,SC2034

set -o pipefail

# Script Constants
readonly CURDIR="$(cd -P -- "$(dirname -- "")" && pwd -P)"
readonly SCRIPT="$(basename "$0")"
# Default log level (debug logs are disabled)
LOG_LVL=0

# Handle Signals
# trap ctrl-c and SIGTERM
trap ctrl_c_signal_handler INT
trap term_signal_handler SIGTERM

function ctrl_c_signal_handler() {
  log_error "User Interrupt! CTRL-C"
  exit 4
}
function term_signal_handler() {
  log_error "Signal Interrupt! SIGTERM"
  exit 4
}

#>> diana::snippet:bash-logger:begin <<#
# shellcheck shell=bash

# BASH LOGGING LIBRARY
# See https://github.com/tprasadtp/dotfiles/logger/README.md
# If included in other files, contents between snippet markers is
# automatically updated and all changes wil be ignored.

# Logging colors
# - If set they are preserved,
# - Otherwise initialized wit ha readonly variable.
[[ -z ${DARK_GRAY+unset} ]] && readonly DARK_GRAY=$'\e[38;5;246m'
[[ -z ${GRAY+unset} ]] && readonly GRAY=$'\e[38;5;250m'
[[ -z ${GREEN+unset} ]] && readonly GREEN=$'\e[38;5;83m'
[[ -z ${BLUE+unset} ]] && readonly BLUE=$'\e[38;5;81m'
[[ -z ${YELLOW+unset} ]] && readonly YELLOW=$'\e[38;5;214m'
[[ -z ${RED+unset} ]] && readonly RED=$'\e[38;5;197m'

# Default log level and formats
# We set these only if theexisting values are empty
[[ -z $LOG_FMT ]] && declare -g LOG_FMT="pretty"
[[ -z $LOG_LVL ]] && declare -g LOG_LVL="20"

# Logger core
function __logger_core()
{
  # If no arguments were specified return now
  [[ $# -eq 0 ]] && return

  # Determine level based on caller function,
  # and return if not called form known functions.
  # This effectively makes this function private-ish

  if [[ -n $BASH_VERSION ]]; then
    local -r lvl_caller="${FUNCNAME[1]}"
  else
    # Ughh Apple! zsh!
    # Use offset:length as array indexing may start at 1 or 0
    # shellcheck disable=SC2124,SC2154
    local -r lvl_caller="${funcstack[@]:1:1}"
  fi

  case $lvl_caller in
    log_step_variable | log_variable) local -r level=0 ;;
    log_step_debug | log_debug) local -r level=10 ;;
    log_step_info | log_info) local -r level=20 ;;
    log_step_success | log_success) local -r level=20 ;;
    log_step_warning | log_warning) local -r level=30 ;;
    log_step_notice | log_notice) local -r level=35 ;;
    log_step_error | log_error) local -r level=40 ;;
    *) return ;;
  esac

  # Immediately return if log level is not enabled
  [[ ${LOG_LVL} -gt $level ]] && return

  # Detect whether to coloring is disabled based on env variables,
  # and if output Terminal is intractive. This supports both
  # - https://bixense.com/clicolors/ &
  # - https://no-color.org/ standards.

  # Forces colored logs
  # - if CLICOLOR_FORCE is set and non empty and not zero
  #
  if [[ -n ${CLICOLOR_FORCE} ]] && [[ ${CLICOLOR_FORCE} != "0" ]]; then
    local lvl_colorized="true"
    local lvl_color_reset=$'\e[0m'

  # Disable colors if one of the conditions are true
  # - CLICOLOR == 0
  # - NO_COLOR is set to non empty value
  # - TERM is set to dumb
  elif [[ -n $NO_COLOR ]] || [[ $CLICOLOR == "0" ]] || [[ $TERM == "dumb" ]]; then
    local lvl_colorized="false"
    local lvl_color=""
    local lvl_color_reset=""

  # Enable colors if not already disabled or forced and terminal is interactive
  elif [[ -t 1 ]]; then
    local lvl_colorized="true"
    local lvl_color_reset=$'\e[0m'

  # Default=disable colors
  else
    local lvl_colorized="false"
    local lvl_color=""
    local lvl_color_reset=""
  fi

  # Log Format
  if [[ $LOG_FMT == "full" || $LOG_FMT == "long" || $lvl_colorized == "false" ]]; then
    local -r lvl_prefix="$(date --rfc-3339=s)"
    local -r lvl_fmt="long"
  elif [[ $lvl_caller == *"step"* ]]; then
    local -r lvl_string="  -"
    local -r lvl_fmt="pretty"
  else
    local -r lvl_string="â€¢"
    local -r lvl_fmt="pretty"
  fi

  # Define level, color and timestamp
  # By default we do not show log level and timestamp.
  # However, if LOG_FMT is set to "full" or "long" or if colors are disabled,
  # we will enable long format with timestamps
  case $lvl_caller in
    log_step_variable | log_variable)
      [[ $lvl_fmt  == "long"  ]] && local -r lvl_string="$lvl_prefix [TRACE ]"
      [[ $lvl_colorized == "true" ]] && local lvl_color="${DARK_GRAY}"
      ;;
    log_step_debug | log_debug)
      [[ $lvl_fmt  == "long"  ]] && local -r lvl_string="$lvl_prefix [DEBUG ]"
      [[ $lvl_colorized == "true" ]] && local lvl_color="${GRAY}"
      ;;
    log_step_info | log_info)
      [[ $lvl_fmt  == "long"  ]] && local -r lvl_string="$lvl_prefix [INFO  ]"
      ;;
    log_step_success | log_success)
      [[ $lvl_fmt  == "long"  ]] && local -r lvl_string="$lvl_prefix [OK    ]"
      [[ $lvl_colorized == "true" ]] && local lvl_color="${GREEN}"
      ;;
    log_step_warning | log_warning)
      [[ $lvl_fmt  == "long"  ]] && local -r lvl_string="$lvl_prefix [WARN  ]"
      [[ $lvl_colorized == "true" ]] && local lvl_color="${YELLOW}"
      ;;
    log_step_notice | log_notice)
      [[ $lvl_fmt  == "long"  ]] && local -r lvl_string="$lvl_prefix [NOTICE]"
      [[ $lvl_colorized == "true" ]] && local lvl_color="${BLUE}"
      ;;
    log_step_error | log_error)
      [[ $lvl_fmt  == "long"  ]] && local -r lvl_string="$lvl_prefix [ERROR ]"
      [[ $lvl_colorized == "true" ]] && local lvl_color="${RED}"
      ;;
    *)
      [[ $lvl_fmt  == "long"  ]] && local -r lvl_string="$lvl_prefix [UNKOWN] $lvl_caller"
      ;;
  esac

  # Log Event
  local msg="$*"
  if [[ ${LOG_TO_STDERR} == "true" ]]; then
    printf "%s%s %s %s\n" "$lvl_color" "${lvl_string}" "$msg" "${lvl_color_reset}" 1>&2
  else
    printf "%s%s %s %s\n" "$lvl_color" "${lvl_string}" "$msg" "${lvl_color_reset}"
  fi
}

# Logger public functions
function log_debug()
{
  __logger_core "$@"
}

function log_info()
{
  __logger_core "$@"
}

function log_success()
{
  __logger_core "$@"
}

function log_notice()
{
  __logger_core "$@"
}

function log_warning()
{
  __logger_core "$@"
}

function log_error()
{
  __logger_core "$@"
}

function log_variable()
{
  local -r var="$1"
  if [[ -n $BASH_VERSION ]]; then
    local -r msg="$var=${!var}"
  else
    local -r msg="$var=${(P)var}"
  fi
  __logger_core "$msg"
}

function log_step_debug()
{
  __logger_core "$@"
}

function log_step_info()
{
  __logger_core "$@"
}

function log_step_success()
{
  __logger_core "$@"
}

function log_step_notice()
{
  __logger_core "$@"
}

function log_step_warning()
{
  __logger_core "$@"
}

function log_step_error()
{
  __logger_core "$@"
}

function log_step_variable()
{
  local -r var="$1"
  if [[ -n $BASH_VERSION ]]; then
    local -r msg="$var=${!var}"
  else
    local -r msg="$var=${(P)var}"
  fi
  __logger_core "$msg"
}
#>> diana::snippet:bash-logger:end <<#

# Checks if command is available
function has_command() {
  if command -v "$1" >/dev/null; then
    return 0
  else
    return 1
  fi
  return 1
}



function run_vnc()
{
  # Because modules sometimes do not load variables into shell
  load_modules

  if [[ -d $HOME/.vnc ]]; then
    log_debug ".vnc directory exists!"
  else
    log_info "Creating ~/.vnc"
    if mkdir -p "$HOME/.vnc"; then
      log_success "OK"
    else
      log_error "Failed to create logs and config folder ~/.vnc"
      exit 1
    fi
  fi

  if has_command vncserver; then

    # Use better res, auto kill and start xfce scession properly
    if [[ $disable_autokill == "true" ]]; then
      AUTOKILL=""
    else
      AUTOKILL="-autokill"
    fi

    if [[ $enable_vgl == "true" ]]; then
      TVNC_VGL=1
    else
      TVNC_VGL=0
    fi
    log_info "Starting new VNC sesion"
    TVNC_VGL="${TVNC_VGL}" "${TURBOVNC_DIR}/bin/vncserver" \
      "${AUTOKILL}" \
      -geometry "${WM_RESOLUTION}" \
      -fp "${HOME}/.local/share/fonts" \
      -log "${HOME}/.vnc/vncserver.log" \
      -wm "startxfce4" &> /dev/null
    exit_code="$?"
    if [[ $exit_code -ne 0 ]]; then
      log_error "something went wrong while running vnc server."
      exit "${exit_code}"
    else
      log_success "Successfully started VNC server."
      log_success "To see how to connect to it run the script with --info"
    fi
  else
    log_error "Cannot find vncserver command! Allow the script to load modules!"
    exit 1
  fi
}

function load_modules()
{
  if [[ $load_required_modeule == "false" ]]; then
    log_warning "Skipped loading Modules!!"
  else
    log_info "Loading Latest VNC module"
    # Cant avoid eval here
    eval module load tools/turbovnc/latest &> /dev/null
  fi
}

function vnc_kill()
{
  local displays

  load_modules
  #shellcheck disable=SC2009
  displays="$(ps -ef | grep "$USER" | grep '[X]vnc' | awk '{print $9}' | tr -d :)"

  if [ -n "$displays" ]; then
    #shellcheck disable=SC2116
    for d in $(echo "$displays"); do
      log_debug "Stopping vnc server on display:$d"
      read -rp "Do you want to stop vncserver :${d} (y/N) " yesno
      #Needed because bash on nemo is too old
      #shellcheck disable=SC2019,SC2018
      ans=$(echo "${yesno}" | tr "A-Z" "a-z")
      if [[ ${ans} == "y" ]];then
        "${TURBOVNC_DIR}"/bin/vncserver -kill ":${d}"
      fi
    done
  else
    log_error "No running servers were detected!"
  fi
}


function display_info()
{
  node_name=$(hostname)
  connection_count="$(pgrep -a -u "$USER" [X]vnc | awk '{print $3}' | tr -d : | wc -l)"
  if [[ connection_count -gt 0 ]];then
    log_success "There are ${connection_count} active sessions"

    # for file in ${HOME}/.vnc/${node_name}\:*.pid; do
    while read -p -r line; do
      port=$((5900+line))
      vnc_ports+=("$port")
    done < <(pgrep -a -u "$USER" [X]vnc | awk '{print $3}' | tr -d : )

    echo ""
    echo "Linux"
    echo "--------------------"
    for p in "${vnc_ports[@]}"; do
      echo "* ssh -fCNL ${p}:${node_name}:${p} ${USER}@login.nemo.uni-freiburg.de"
    done
    echo ""
    echo "Windows PuTTY"
    echo "--------------------"
    echo "Start another Putty session and navigate to Connection -> SSH -> Tunnels"
    for p in "${vnc_ports[@]}"; do
      echo "* Source Port: ${p} Destination: ${node_name}:${p}"
    done

    echo ""
    echo "VNC Viewer Address(s)"
    echo "-------------------------"
    for p in "${vnc_ports[@]}"; do
      echo "* localhost:${p}"
    done
    echo ""
    echo "Tips"
    echo "-----------"
    echo "These addresses are only active after you complete Linux/Windows specific steps/commands above."
    echo "To kill the sessions, "
    echo "  * logout (if you did not disable autokill)"
    echo "  * use vnc-session --kill command."
  else
    log_error "There are no active VNC sessions on this node!"
  fi
}

function display_usage()
{
#Prints out help menu
cat <<EOF
Handy utility to run VNC server.

Usage: ${GREEN}${SCRIPT} ${BLUE}  [options]${NC}
---------------------------------------------
[-r --resolution]        Geometry Params (default=1920x1080)
[-i --info]              Display connection info]
[-k --kill]              Kill all running VNC sessions
[-a --disable-autokill]  Disables passing -autokill to vnc module.
                          This has a side effect of not killing the
                          server, even when you click logout.
                          Use with caution.
[-m --skip-load]         Skip Loading modules
[-v --enable-vgl]        Enables vgl.
[-h --help]              Display this help message]

Notes on resolution parameter
----------------------------------
Resolution MUST be of format

a) W0xH0+X0+Y0[,W1xH1+X1+Y1,...,WnxHn+Xn+Yn]
  Set multi-screen  geometry  of  the virtual X display.
  Wi and Hi are the width and height of Screen i, and Xi and Yi.
  specify the offset of Screen i relative to the origin.
  The total width and height are determined by the bounding box of all screens.
b) widthxheight
  Set width and height of the virtual X display.

Author : Prasad Tengse <prasad.tengse@venus.uni-freiburg.de>
VCS    : https://github.com/imtek-emp/hpc-dotfiles.git
EOF
}

function main()
{

  run_mode="run"
  WM_RESOLUTION="1920x1080"


  while [ "${1}" != "" ]; do
    case ${1} in
      -r | --resolution )       shift;WM_RESOLUTION="${1}";
                                ;;
      -g | --enable-vgl)        enable_vgl="true";
                                ;;
      -a | --disable-autokill)  disable_autokill="true";
                                ;;
      -i | --info)              run_mode="info";
                                ;;
      -k | --kill)              run_mode="kill";
                                ;;
      -m | --skip-load)         load_required_modeule="false";
                                ;;
      # Debugging options
      --stderr)                 LOG_TO_STDERR="true";;
      -v | --verbose)           LOG_LVL="1";
                                log_info "Enable verbose logging";;
      -h | --help )             display_usage;exit 0;;
      * )                       log_error "Invalid argument(s). See usage below.";
                                usage; exit 1;;
    esac
    shift
  done

  if [[ -z $WM_RESOLUTION ]]; then
    log_error "WM_RESOLUTION is undefined!"
    exit 1
  else
    log_debug "Setting geometry params to $WM_RESOLUTION"
  fi

  # Run
  case "${run_mode}" in
    run)        run_vnc;;
    kill)       vnc_kill;;
    info)       display_info;exit $?;;
    *)          log_error "Internal Error! Invalid mode!";exit 1;;
  esac


}

main "$@"
